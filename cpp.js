{
    "CPP1": {
    "prefix": "hekk",
    "body": [
      "#include<deque>",
      "#include<queue>",
      "#include<vector>",
      "#include<set>",
      "#include<map>",
      "#include<unordered_map>",
      "#include<iostream>",
      "#include<algorithm>",
      "#include<bitset>",
      "#include<cmath>",
      "#include<cstring>",
      "#include<cassert>",
      "#include<random>",
      "#include<fstream>",
      "#include<chrono>",
      "// #include<ext/pb_ds/assoc_container.hpp>",
      "// #include<ext/pb_ds/tree_policy.hpp>",
      "// using namespace __gnu_pbds;",
      "using namespace std;",
      "#define int          long long",
      "#define ld           long double",
      "#define pii          pair<int,int>",
      "#define vi           vector<int>",
      "#define pb           push_back",
      "#define mp           make_pair",
      "#define ff           first",
      "#define ss           second",
      "#define rep(i,s,e)   for(int i=(s);i<=(e);i++)",
      "#define brep(i,s,e)  for(int i=(s);i>=(e);i--)",
      "#define all(x)       (x).begin(),(x).end()",
      "#define ball(x)      (x).rbegin(),(x).rend()",
      "#define sz(x)        (int)x.size()",
      "#define mem(x,y)     memset(x,y,sizeof(x))",
      "#define VR46         ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);ifstream fin(\"ip.txt\");ofstream fout(\"op.txt\");",
      "#define milf(x)      x.reserve(1LL<<14LL); x.max_load_factor(0.25); // less_equal",
      "#define pbds         tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
      "mt19937              rng(chrono::steady_clock::now().time_since_epoch().count());",
      "const int MOD = 1e9+7;",
      "const int INF = 0x3F3F3F3F3F3F3F3F;",
      "ld EPS = 1e-12;",
      "",
      "signed main()",
      "{",
      "    VR46 // GANDU TEST CASE BNALE",
      "    // int t;cin>>t;rep(test,1,t)",
      "    {",
      "        $1",
      "    }",
      "}"
    ],
    "description": "CPP"
    },
    "CPP2": {
    "prefix": "bojack",
    "body": [
      "/*",
      "  \"Piece of shit. Stupid piece of shit. I'm a real stupid piece",
      "   of shit. But I know I'm a piece of shit. That at least makes",
      "   me better than all the pieces of shit that don't know they're",
      "   pieces of shit. Or is it worse?\"",
      "     - BoJack F. Horseman",
      "*/",
      "#include<iostream>",
      "#include<algorithm>",
      "#include<bitset>",
      "#include<cmath>",
      "#include<cstring>",
      "#include<climits>",
      "#include<random>",
      "#include<fstream>",
      "#include<chrono>",
      "",
      "#include<deque>",
      "#include<queue>",
      "#include<vector>",
      "#include<list>",
      "#include<set>",
      "#include<map>",
      "#include<unordered_map>",
      "// #include<ext/pb_ds/assoc_container.hpp>",
      "// #include<ext/pb_ds/tree_policy.hpp>",
      "// using namespace __gnu_pbds;",
      "using namespace std;",
      "",
      "#define int          long long",
      "#define ld           long double",
      "#define pii          pair<int,int>",
      "#define vi           vector<int>",
      "#define maxpq        priority_queue<int>",
      "#define minpq        priority_queue<int,vi,greater<int>>",
      "#define pb           push_back",
      "#define mp           make_pair",
      "#define ff           first",
      "#define ss           second",
      "#define endl         '\\n'",
      "#define rep(i,s,e)   for(int i=s;i<=e;i++)",
      "#define brep(i,s,e)  for(int i=s;i>=e;i--)",
      "#define all(x)       (x).begin(),(x).end()",
      "#define ball(x)      (x).rbegin(),(x).rend()",
      "#define sz(x)        (int)x.size()",
      "#define mem(x,y)     memset(x,y,sizeof(x))",
      "#define milf(x)      x.reserve(1LL<<14LL); x.max_load_factor(0.25);",
      "#define pbds         tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
      "#define VR46         ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);",
      "mt19937              rng(chrono::steady_clock::now().time_since_epoch().count());",
      "",
      "const int MOD = 1e9+7;",
      "ld EPS = 1e-12;",
      "const int INF32 = 0x3F3F3F3F;",
      "const int INF = 0x3F3F3F3F3F3F3F3F;",
      "const int crng = rng();",
      "",
      "signed main()",
      "{",
      "    VR46 ifstream fin(\"input.txt\"); ofstream fout(\"output.txt\");",
      "    // auto start = chrono::high_resolution_clock::now();",
      "",
      "    // GANDU TEST CASE BNAKE TEST KRLE; CHECK BOUNDS;",
      "    // int t; cin>>t; rep(test,1,t)",
      "    {",
      "        $1",
      "    }",
      "",
      "    // auto stop = chrono::high_resolution_clock::now();",
      "    // auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start); ",
      "    // cout<<\"Time taken by function: \"<<duration.count()<<\" milliseconds\"<<endl;",
      "",
      "    // *( hsh.find_by_order(k) ) kth smallest, from 0",
      "    // hsh.order_of_key(k) num of ele str less than k",
      "    // change less to less_equal for multiset pbds",
      "    // Create struct HASH; Use milf(x) for every hashmap; Use CRNG xor;",
      "}"
    ],
    "description": "CPP"
    },
    "DSU": {
    "prefix": "dsu",
    "body": [
        "int par[(int)4e5+5];mem( par,-1 );",
        "int PARENT(int x)",
        "{",
        "    int root = x;",
        "    while( par[root]>=0 ) root = par[root];",
        "    while( x!=root )",
        "    {",
        "        int old = x;",
        "        x = par[x];",
        "        par[old] = root;",
        "    }",
        "    return root;",
        "}",
        "void UNITE(int x, int y)",
        "{",
        "    x = PARENT(x), y = PARENT(y);",
        "    if( x==y ) return;",
        "    if( par[x]>par[y] ) swap( x,y );",
        "    par[x] += par[y], par[y] = x;",
        "}"
    ],
    "description": "DSU"
    },
    "MODEXP": {
    "prefix": "modexp",
    "body": [
        "int modexp(int base, int exp)",
        "{",
        "    int res = 1;",
        "    while( exp>0 )",
        "    {",
        "        if( exp&(int)1 ) res *= base, res %= MOD;",
        "        base *= base, base %= MOD, exp >>= (int)1;",
        "    }",
        "    return res;",
        "}"
    ],
    "description": "MODEXP"
    },
    "MODINV": {
    "prefix": "modinv",
    "body": [
        "// Extended Euclidean Algorithm ax + by = gcd(a,b)",
        "// returns gcd and stores x and y",
        "int exgcd(int a, int b, int &x, int &y)",
        "{",
        "    int g = a; x = 1, y = 0;",
        "    if( b ) g = exgcd( b,a%b,y,x ), y -= (a/b)*x;",
        "    return g;",
        "}",
        "",
        "// Modular Multiplicative Inverse of a (mod m)",
        "int modinv(int a, int m)",
        "{",
        "    int x, y;",
        "    exgcd( a,m,x,y );",
        "    return ( x+m )%m;",
        "}"
    ],
    "description": "MODINV"
    },
    "SIEVE": {
    "prefix": "sieve",
    "body": [
        "vi prime;",
        "vi comp;",
        "bool isp[(int)1e7+6];",
        "void sieve(int n = 1e7+5)",
        "{",
        "    mem( isp,true );",
        "    isp[0] = isp[1] = false;",
        "    for(int j=4; j<=n; j+=2) isp[j] = false;",
        "    for(int i=3; i*i<=n; i+=2)",
        "    {",
        "        if( !isp[i] ) continue;",
        "        for(int j=i*i; j<=n; j+=i) isp[j] = false;",
        "    }",
        "    rep(i,2,n) isp[i] ? prime.pb(i) : comp.pb(i);",
        "}"
    ],
    "description": "SIEVE"
    },
    "PRIMEFACTORIZATION": {
    "prefix": "primef",
    "body": [
        "vi pfac;",
        "void primefac(int n)",
        "{",
        "    for(int i=2; i*i<=n; i++)",
        "    {",
        "        if( n%i != 0 ) continue;",
        "        pfac.pb( i );",
        "        while( n%i==0 ) n/=i;",
        "    }",
        "    if( n>1 ) pfac.pb( n );",
        "}"
    ],
    "description": "PRIMEFACTORIZATION"
    },
    "FACTORIZATION": {
    "prefix": "fac",
    "body": [
        "vi div;",
        "void factorize(int n)",
        "{",
        "    for(int i=1; i*i<=n; i++)",
        "    {",
        "        if( n%i != 0 ) continue;",
        "        div.pb( i );",
        "        if( i*i != n )",
        "        div.pb( n/i );",
        "    }",
        "}"
    ],
    "description": "FACTOR"
    },
    "HASH": {
    "prefix": "milf",
    "body": [
        "struct HASH",
        "{",
        "    static uint64_t splitmix64(uint64_t x)",
        "    {",
        "        x += UINT64_C(0x9e3779b97f4a7c15);",
        "        x = (x ^ (x >> 30)) * UINT64_C(0xbf58476d1ce4e5b9);",
        "        x = (x ^ (x >> 27)) * UINT64_C(0x94d049bb133111eb);",
        "        return x ^ (x >> 31);",
        "    }",
        "    size_t operator()(uint64_t x) const",
        "    {  return splitmix64( x+crng );  }",
        "};",
        ""
    ],
    "description": "HASH"
    }
}
